46
This is a proof cache file generated by zvtov.
35
zvtov version 0.6.0 [32] 2009-12-03
2097
zenon -x focal -q -short -max-time 5m -x induct
zenon version 0.8.0 [a263] 2014-10-21
$Id: 8d3e74063353abcfefb6c4de625febcd0a10705c $
$Id: 0bb7ad8565ca1ee59ff5edffa7ed2b2d882c4f93 $
$Id: 8e2e984e1f30ddc3be6823ddc9ccf8f6877e7be1 $
$Id: e9a1445bc3b916bc344e12b5e1465a20b7569e8a $
$Id: 3543f411fd78f652dbf8224d7fe56e5a2c83df42 $
$Id: c483db8583b833b9d90ee5c1b90af4da4befefcf $
$Id: e962f33dc5753e15a88c3aef2170d1c552a80be7 $
$Id: 239c76ade6485f65b50499d4af616ed6394f9892 $
$Id: 960020f638c3d1f11c58184ba83acf7a567f497e $
$Id: 0d2f93a609978187340ccdc540d8b4709e3e3626 $
$Id: 0bba51e302cc27e4dcf7dd8783da6e6517e1ca2e $
$Id: 123bd672b267fe3d464ae13f9c8b98e7475c12b6 $
$Id: c891513dc0a7214f92f52e8c6f59be0c3a6bdc75 $
$Id: d674fd7fb29144c5978cd8f2421c4147c86781c8 $
$Id: 75e59fa998ba43be0fae0fc16452e5c75f01a317 $
$Id: lexcoq.mll,v 1.16 2012-04-11 18:27:26 doligez Exp $
$Id: parsecoq.mly,v 1.34 2012-04-11 18:27:26 doligez Exp $
$Id: lextptp.mll,v 1.7 2012-04-24 17:32:04 doligez Exp $
$Id: parsetptp.mly,v 1.9 2012-04-24 17:32:04 doligez Exp $
$Id: lexzen.mll,v 1.13 2012-04-11 18:27:26 doligez Exp $
$Id: parsezen.mly,v 1.16 2012-04-11 18:27:26 doligez Exp $
$Id: feacf069839a8c95e03ad2e3dbb03601a3a6607d $
$Id: 200c027cd2683053eb227e68a492c4961e2a5784 $
$Id: 9f00cd3d0af0bdd28d17b64ab051f9594255e67e $
$Id: 52308a30d82a014cf1f8efa2799df8b300a0c678 $
$Id: caed5ca44e929aef76195d58649e867d28c61885 $
$Id: 8bef787c38724f2923554c6d72f7b8d9c6f4ab2b $
$Id: 799ea945a49520c4ac8520bb6c232fbe8b53bed8 $
$Id: 8cdb504db763cd885675be46e2a542d5ec676e25 $
$Id: f21acd58472bbe06f2040f6b4df14b9bcece4be1 $
$Id: 71c3ed8bb8ff5d2866be86682d871a07f130b74f $
$Id: 4da3a63d30c663a2457badcc920df654f154b47b $
$Id: d0534a6a0c9a349b8289a70cb8f84297d3678ef6 $
$Id: f64f126ba41a6797d6643ecfd2290bdc3bcd7c08 $
$Id: 03e455e19c9d3e35e5edbd6eee048f53fb55908f $
$Id: af6004ec6e3900adb00b13aa1e67da873f9dd706 $
$Id: 81e748142c40d6382b9ceac00a08d35207607f19 $
$Id: cd90a6b20441b688fbac060141ef245237cb7320 $
$Id: 7449d985db563f705bdded478f605f03b7111602 $
$Id: 34c58a3afac083cc607b116f4d95546502fbd4b7 $
source checksum: 20927 1

term

begin
696

%%begin-auto-proof
%%name: for_zenon_consistency_rule_reflexive
    
    
    
    (* Methods to use for automated proof. *)
    (* For step <1>1. *)
    Parameter __A_1_LEMMA : forall x : abst_T,
      (Is_true ((_p_T_geq (_p_T_plus x _p_tol_tol) x))).
    (* For method of Self used via "by definition of !consistency_rule". *)
    Definition abst_consistency_rule (x : abst_T) (y : abst_T) :
      basics.bool__t :=
      (if (_p_T_geq x y) then (_p_T_geq (_p_T_plus y _p_tol_tol) x)
        else (_p_T_geq (_p_T_plus x _p_tol_tol) y)).
    (* Theorem's body. *)
    Theorem for_zenon_consistency_rule_reflexive :
    forall a : abst_T, Is_true ((abst_consistency_rule a a)).
%%end-auto-proof
0
9f10b5e7b6cd7c4d9be5207748f4b79c
proof
1060
Theorem for_zenon_consistency_rule_reflexive:(forall a:abst_T,(Is_true (
abst_consistency_rule a a))).
Proof.
exact(
let zenon_L1_:(forall zenon_Ta_c:abst_T,((~(Is_true (_p_T_geq (
_p_T_plus zenon_Ta_c _p_tol_tol) zenon_Ta_c)))->False)):=
(fun(zenon_Ta_c:abst_T)(zenon_H3:(~(Is_true (_p_T_geq (_p_T_plus
zenon_Ta_c _p_tol_tol) zenon_Ta_c))))=>(zenon_all abst_T (fun x:abst_T=>
(Is_true (_p_T_geq (_p_T_plus x _p_tol_tol) x))) zenon_Ta_c (fun
zenon_H4=>(zenon_H3 zenon_H4)) __A_1_LEMMA))in
(NNPP _ (fun zenon_G=>(zenon_notallex (fun a:abst_T=>(Is_true (
abst_consistency_rule a a))) (fun zenon_H9=>(zenon_ex abst_T (fun a
:abst_T=>(~(Is_true (abst_consistency_rule a a)))) (fun(zenon_Ta_c
:abst_T) zenon_H8=>(let zenon_H7:=zenon_H8 in (zenon_focal_ite_bool_n (
_p_T_geq zenon_Ta_c zenon_Ta_c) (_p_T_geq (_p_T_plus zenon_Ta_c
_p_tol_tol) zenon_Ta_c) (_p_T_geq (_p_T_plus zenon_Ta_c _p_tol_tol)
zenon_Ta_c) (fun zenon_H5 zenon_H3=>(zenon_L1_ zenon_Ta_c zenon_H3)) (
fun zenon_H6 zenon_H3=>(zenon_L1_ zenon_Ta_c zenon_H3)) zenon_H7)))
zenon_H9)) zenon_G)))).
Qed.

0
d9e12840aaa5339816df5f93c1180878
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
586

%%begin-auto-proof
%%name: for_zenon_equal_reflexive
    
    
    
    (* Methods to use for automated proof. *)
    (* For species parameter method used via "by property value#T!equal_reflexive". *)
    Parameter _p_T_equal_reflexive :
      forall x : _p_T_T, Is_true ((_p_T_equal x x)).
    (* For method of Self used via "by definition of !equal". *)
    Definition abst_equal (x : abst_T) (y : abst_T) : basics.bool__t :=
      (_p_T_equal x y).
    (* Theorem's body. *)
    Theorem for_zenon_equal_reflexive :
    forall x : abst_T, Is_true ((abst_equal x x)).
%%end-auto-proof
0
1c9c96c11bfd4ac5c4f5c4e9137a8a47
proof
478
Theorem for_zenon_equal_reflexive:(forall x:abst_T,(Is_true (abst_equal
x x))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_notallex (fun x:abst_T=>(Is_true (
abst_equal x x))) (fun zenon_H6=>(zenon_ex abst_T (fun x:abst_T=>(~(
Is_true (abst_equal x x)))) (fun(zenon_Tx_e:abst_T) zenon_H5=>(let
zenon_H3:=zenon_H5 in (zenon_all _p_T_T (fun x:_p_T_T=>(Is_true (
_p_T_equal x x))) zenon_Tx_e (fun zenon_H2=>(zenon_H3 zenon_H2))
_p_T_equal_reflexive))) zenon_H6)) zenon_G)))).
Qed.

0
2cac32e9298f6c2f3f4b85fc20f7a0f4
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
666

%%begin-auto-proof
%%name: for_zenon_equal_symmetric
    
    
    
    (* Methods to use for automated proof. *)
    (* For species parameter method used via "by property value#T!equal_symmetric". *)
    Parameter _p_T_equal_symmetric :
      forall x  y : _p_T_T,
        Is_true ((_p_T_equal x y)) -> Is_true ((_p_T_equal y x)).
    (* For method of Self used via "by definition of !equal". *)
    Definition abst_equal (x : abst_T) (y : abst_T) : basics.bool__t :=
      (_p_T_equal x y).
    (* Theorem's body. *)
    Theorem for_zenon_equal_symmetric :
    forall x  y : abst_T,
      Is_true ((abst_equal x y)) -> Is_true ((abst_equal y x)).
%%end-auto-proof
0
b70a2019415cdc032e7310fc2f62afb9
proof
1275
Theorem for_zenon_equal_symmetric:(forall x:abst_T,(forall y:abst_T,((
Is_true (abst_equal x y))->(Is_true (abst_equal y x))))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_notallex (fun x:abst_T=>(forall y:abst_T,((
Is_true (abst_equal x y))->(Is_true (abst_equal y x))))) (fun zenon_Hf=>
(zenon_ex abst_T (fun x:abst_T=>(~(forall y:abst_T,((Is_true (
abst_equal x y))->(Is_true (abst_equal y x)))))) (fun(zenon_Tx_c:abst_T)
 zenon_He=>(zenon_notallex (fun y:abst_T=>((Is_true (abst_equal
zenon_Tx_c y))->(Is_true (abst_equal y zenon_Tx_c)))) (fun zenon_Hd=>(
zenon_ex abst_T (fun y:abst_T=>(~((Is_true (abst_equal zenon_Tx_c y))->(
Is_true (abst_equal y zenon_Tx_c))))) (fun(zenon_Ty_j:abst_T) zenon_Hc=>
(zenon_notimply _ _ (fun zenon_Hb zenon_Ha=>(let zenon_H5:=zenon_Hb in (
let zenon_H4:=zenon_Ha in (zenon_all _p_T_T (fun x:_p_T_T=>(forall y
:_p_T_T,((Is_true (_p_T_equal x y))->(Is_true (_p_T_equal y x)))))
zenon_Tx_c (fun zenon_H8=>(zenon_all _p_T_T (fun y:_p_T_T=>((Is_true (
_p_T_equal zenon_Tx_c y))->(Is_true (_p_T_equal y zenon_Tx_c))))
zenon_Ty_j (fun zenon_H7=>(zenon_imply _ _ (fun zenon_H6=>(zenon_H6
zenon_H5)) (fun zenon_H3=>(zenon_H4 zenon_H3)) zenon_H7)) zenon_H8))
_p_T_equal_symmetric)))) zenon_Hc)) zenon_Hd)) zenon_He)) zenon_Hf))
zenon_G)))).
Qed.

0
c5d9363ecbdc3b11d080ddc44e1af856
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
754

%%begin-auto-proof
%%name: for_zenon_equal_transitive
    
    
    
    (* Methods to use for automated proof. *)
    (* For species parameter method used via "by property value#T!equal_transitive". *)
    Parameter _p_T_equal_transitive :
      forall x  y  z : _p_T_T,
        Is_true ((_p_T_equal x y)) ->
          Is_true ((_p_T_equal y z)) -> Is_true ((_p_T_equal x z)).
    (* For method of Self used via "by definition of !equal". *)
    Definition abst_equal (x : abst_T) (y : abst_T) : basics.bool__t :=
      (_p_T_equal x y).
    (* Theorem's body. *)
    Theorem for_zenon_equal_transitive :
    forall x  y  z : abst_T,
      Is_true ((abst_equal x y)) ->
        Is_true ((abst_equal y z)) -> Is_true ((abst_equal x z)).
%%end-auto-proof
0
c64835edbac2d1e8c2c5ad83087f9a70
proof
3275
Theorem for_zenon_equal_transitive:(forall x:abst_T,(forall y:abst_T,(
forall z:abst_T,((Is_true (abst_equal x y))->((Is_true (abst_equal y z))
->(Is_true (abst_equal x z))))))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_notallex (fun x:abst_T=>(forall y:abst_T,(
forall z:abst_T,((Is_true (abst_equal x y))->((Is_true (abst_equal y z))
->(Is_true (abst_equal x z))))))) (fun zenon_H24=>(zenon_ex abst_T (fun
x:abst_T=>(~(forall y:abst_T,(forall z:abst_T,((Is_true (abst_equal x y)
)->((Is_true (abst_equal y z))->(Is_true (abst_equal x z)))))))) (fun(
zenon_Tx_c:abst_T) zenon_H23=>(zenon_notallex (fun y:abst_T=>(forall z
:abst_T,((Is_true (abst_equal zenon_Tx_c y))->((Is_true (abst_equal y z)
)->(Is_true (abst_equal zenon_Tx_c z)))))) (fun zenon_H22=>(zenon_ex
abst_T (fun y:abst_T=>(~(forall z:abst_T,((Is_true (abst_equal
zenon_Tx_c y))->((Is_true (abst_equal y z))->(Is_true (abst_equal
zenon_Tx_c z))))))) (fun(zenon_Ty_d:abst_T) zenon_H21=>(zenon_notallex (
fun z:abst_T=>((Is_true (abst_equal zenon_Tx_c zenon_Ty_d))->((Is_true (
abst_equal zenon_Ty_d z))->(Is_true (abst_equal zenon_Tx_c z))))) (fun
zenon_H20=>(zenon_ex abst_T (fun z:abst_T=>(~((Is_true (abst_equal
zenon_Tx_c zenon_Ty_d))->((Is_true (abst_equal zenon_Ty_d z))->(Is_true
(abst_equal zenon_Tx_c z)))))) (fun(zenon_Tz_f:abst_T) zenon_H1f=>(
zenon_notimply _ _ (fun zenon_H1d zenon_H1e=>(zenon_notimply _ _ (fun
zenon_H1c zenon_H1b=>(let zenon_Hc:=zenon_H1d in (let zenon_H7
:=zenon_H1c in (let zenon_H6:=zenon_H1b in (let zenon_H18:=(fun
zenon_H1a=>(zenon_and _ _ (fun zenon_H16 zenon_Hd=>(zenon_Hd zenon_Hc))
zenon_H1a)) in (let zenon_H4:=(fun zenon_H19=>(zenon_subst _ (fun
zenon_Vf=>(Is_true zenon_Vf)) (_p_T_equal zenon_Ty_d zenon_Tz_f) (
_p_T_equal zenon_Tx_c zenon_Tz_f) (fun zenon_H8=>(zenon_subst _ (fun
zenon_Vg=>(~((_p_T_equal zenon_Vg zenon_Tz_f) = (_p_T_equal zenon_Tx_c
zenon_Tz_f)))) zenon_Ty_d zenon_Tx_c (fun zenon_H13=>(zenon_notand _ _ (
fun zenon_H17=>(zenon_H17 (fun zenon_H15=>(let zenon_H12:=(fun
zenon_H14=>(zenon_subst _ (fun zenon_Vh=>(zenon_Vh = zenon_Tx_c))
zenon_Tx_c zenon_Ty_d (fun zenon_H16=>(zenon_H16 zenon_H15)) zenon_H13
zenon_H14)) in (zenon_noteq _ zenon_Tx_c zenon_H12))))) (fun zenon_H11=>
(zenon_H11 (fun zenon_Hc=>(zenon_all _p_T_T (fun x:_p_T_T=>(forall y
:_p_T_T,(forall z:_p_T_T,((Is_true (_p_T_equal x y))->((Is_true (
_p_T_equal y z))->(Is_true (_p_T_equal x z))))))) zenon_Tx_c (fun
zenon_H10=>(zenon_all _p_T_T (fun y:_p_T_T=>(forall z:_p_T_T,((Is_true (
_p_T_equal zenon_Tx_c y))->((Is_true (_p_T_equal y z))->(Is_true (
_p_T_equal zenon_Tx_c z)))))) zenon_Ty_d (fun zenon_Hf=>(zenon_all
_p_T_T (fun z:_p_T_T=>((Is_true (_p_T_equal zenon_Tx_c zenon_Ty_d))->((
Is_true (_p_T_equal zenon_Ty_d z))->(Is_true (_p_T_equal zenon_Tx_c z)))
)) zenon_Tz_f (fun zenon_He=>(zenon_imply _ _ (fun zenon_Hd=>(zenon_Hd
zenon_Hc)) (fun zenon_Hb=>(zenon_imply _ _ (fun zenon_Ha=>(zenon_Ha
zenon_H7)) (fun zenon_H9=>(zenon_H6 zenon_H9)) zenon_Hb)) zenon_He))
zenon_Hf)) zenon_H10)) _p_T_equal_transitive)))) zenon_H18)) (
zenon_notnot _ (refl_equal (_p_T_equal zenon_Tx_c zenon_Tz_f)))
zenon_H8)) zenon_H6 zenon_H7)) in (zenon_noteq _ zenon_Tz_f zenon_H4))))
))) zenon_H1e)) zenon_H1f)) zenon_H20)) zenon_H21)) zenon_H22))
zenon_H23)) zenon_H24)) zenon_G)))).
Qed.

0
1b24e709969f063d153c00b56f505c81
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
641

%%begin-auto-proof
%%name: for_zenon_consistency_rule_reflexive
    
    
    
    (* Methods to use for automated proof. *)
    (* For species parameter method used via "by property value#T!equal_reflexive". *)
    Parameter _p_T_equal_reflexive :
      forall x : _p_T_T, Is_true ((_p_T_equal x x)).
    (* For method of Self used via "by definition of !consistency_rule". *)
    Definition abst_consistency_rule (x : abst_T) (y : abst_T) :
      basics.bool__t := (_p_T_equal x y).
    (* Theorem's body. *)
    Theorem for_zenon_consistency_rule_reflexive :
    forall a : abst_T, Is_true ((abst_consistency_rule a a)).
%%end-auto-proof
0
c5e35cb255d594c010dbd145a2ff6ec5
proof
525
Theorem for_zenon_consistency_rule_reflexive:(forall a:abst_T,(Is_true (
abst_consistency_rule a a))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_notallex (fun a:abst_T=>(Is_true (
abst_consistency_rule a a))) (fun zenon_H6=>(zenon_ex abst_T (fun a
:abst_T=>(~(Is_true (abst_consistency_rule a a)))) (fun(zenon_Ta_e
:abst_T) zenon_H5=>(let zenon_H3:=zenon_H5 in (zenon_all _p_T_T (fun x
:_p_T_T=>(Is_true (_p_T_equal x x))) zenon_Ta_e (fun zenon_H2=>(
zenon_H3 zenon_H2)) _p_T_equal_reflexive))) zenon_H6)) zenon_G)))).
Qed.

0
9762df774a7104fa08fe56562ef246cf
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
740

%%begin-auto-proof
%%name: for_zenon_consistency_rule_symmetric
    
    
    
    (* Methods to use for automated proof. *)
    (* For species parameter method used via "by property value#T!equal_symmetric". *)
    Parameter _p_T_equal_symmetric :
      forall x  y : _p_T_T,
        Is_true ((_p_T_equal x y)) -> Is_true ((_p_T_equal y x)).
    (* For method of Self used via "by definition of !consistency_rule". *)
    Definition abst_consistency_rule (x : abst_T) (y : abst_T) :
      basics.bool__t := (_p_T_equal x y).
    (* Theorem's body. *)
    Theorem for_zenon_consistency_rule_symmetric :
    forall a  b : abst_T,
      Is_true ((abst_consistency_rule a b)) ->
        Is_true ((abst_consistency_rule b a)).
%%end-auto-proof
0
d6bcabcedd8261e91f68288e022c100f
proof
1396
Theorem for_zenon_consistency_rule_symmetric:(forall a:abst_T,(forall b
:abst_T,((Is_true (abst_consistency_rule a b))->(Is_true (
abst_consistency_rule b a))))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_notallex (fun a:abst_T=>(forall b:abst_T,((
Is_true (abst_consistency_rule a b))->(Is_true (abst_consistency_rule b
a))))) (fun zenon_Hf=>(zenon_ex abst_T (fun a:abst_T=>(~(forall b
:abst_T,((Is_true (abst_consistency_rule a b))->(Is_true (
abst_consistency_rule b a)))))) (fun(zenon_Ta_c:abst_T) zenon_He=>(
zenon_notallex (fun b:abst_T=>((Is_true (abst_consistency_rule
zenon_Ta_c b))->(Is_true (abst_consistency_rule b zenon_Ta_c)))) (fun
zenon_Hd=>(zenon_ex abst_T (fun b:abst_T=>(~((Is_true (
abst_consistency_rule zenon_Ta_c b))->(Is_true (abst_consistency_rule b
zenon_Ta_c))))) (fun(zenon_Tb_j:abst_T) zenon_Hc=>(zenon_notimply _ _ (
fun zenon_Hb zenon_Ha=>(let zenon_H5:=zenon_Hb in (let zenon_H4
:=zenon_Ha in (zenon_all _p_T_T (fun x:_p_T_T=>(forall y:_p_T_T,((
Is_true (_p_T_equal x y))->(Is_true (_p_T_equal y x))))) zenon_Ta_c (
fun zenon_H8=>(zenon_all _p_T_T (fun y:_p_T_T=>((Is_true (_p_T_equal
zenon_Ta_c y))->(Is_true (_p_T_equal y zenon_Ta_c)))) zenon_Tb_j (fun
zenon_H7=>(zenon_imply _ _ (fun zenon_H6=>(zenon_H6 zenon_H5)) (fun
zenon_H3=>(zenon_H4 zenon_H3)) zenon_H7)) zenon_H8))
_p_T_equal_symmetric)))) zenon_Hc)) zenon_Hd)) zenon_He)) zenon_Hf))
zenon_G)))).
Qed.

0
8198a3a1f56105b6a48d06cea58ae85a
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
586

%%begin-auto-proof
%%name: for_zenon_equal_reflexive
    
    
    
    (* Methods to use for automated proof. *)
    (* For species parameter method used via "by property value#T!equal_reflexive". *)
    Parameter _p_T_equal_reflexive :
      forall x : _p_T_T, Is_true ((_p_T_equal x x)).
    (* For method of Self used via "by definition of !equal". *)
    Definition abst_equal (x : abst_T) (y : abst_T) : basics.bool__t :=
      (_p_T_equal x y).
    (* Theorem's body. *)
    Theorem for_zenon_equal_reflexive :
    forall x : abst_T, Is_true ((abst_equal x x)).
%%end-auto-proof
0
1c9c96c11bfd4ac5c4f5c4e9137a8a47
proof
478
Theorem for_zenon_equal_reflexive:(forall x:abst_T,(Is_true (abst_equal
x x))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_notallex (fun x:abst_T=>(Is_true (
abst_equal x x))) (fun zenon_H6=>(zenon_ex abst_T (fun x:abst_T=>(~(
Is_true (abst_equal x x)))) (fun(zenon_Tx_e:abst_T) zenon_H5=>(let
zenon_H3:=zenon_H5 in (zenon_all _p_T_T (fun x:_p_T_T=>(Is_true (
_p_T_equal x x))) zenon_Tx_e (fun zenon_H2=>(zenon_H3 zenon_H2))
_p_T_equal_reflexive))) zenon_H6)) zenon_G)))).
Qed.

0
2cac32e9298f6c2f3f4b85fc20f7a0f4
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
666

%%begin-auto-proof
%%name: for_zenon_equal_symmetric
    
    
    
    (* Methods to use for automated proof. *)
    (* For species parameter method used via "by property value#T!equal_symmetric". *)
    Parameter _p_T_equal_symmetric :
      forall x  y : _p_T_T,
        Is_true ((_p_T_equal x y)) -> Is_true ((_p_T_equal y x)).
    (* For method of Self used via "by definition of !equal". *)
    Definition abst_equal (x : abst_T) (y : abst_T) : basics.bool__t :=
      (_p_T_equal x y).
    (* Theorem's body. *)
    Theorem for_zenon_equal_symmetric :
    forall x  y : abst_T,
      Is_true ((abst_equal x y)) -> Is_true ((abst_equal y x)).
%%end-auto-proof
0
b70a2019415cdc032e7310fc2f62afb9
proof
1275
Theorem for_zenon_equal_symmetric:(forall x:abst_T,(forall y:abst_T,((
Is_true (abst_equal x y))->(Is_true (abst_equal y x))))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_notallex (fun x:abst_T=>(forall y:abst_T,((
Is_true (abst_equal x y))->(Is_true (abst_equal y x))))) (fun zenon_Hf=>
(zenon_ex abst_T (fun x:abst_T=>(~(forall y:abst_T,((Is_true (
abst_equal x y))->(Is_true (abst_equal y x)))))) (fun(zenon_Tx_c:abst_T)
 zenon_He=>(zenon_notallex (fun y:abst_T=>((Is_true (abst_equal
zenon_Tx_c y))->(Is_true (abst_equal y zenon_Tx_c)))) (fun zenon_Hd=>(
zenon_ex abst_T (fun y:abst_T=>(~((Is_true (abst_equal zenon_Tx_c y))->(
Is_true (abst_equal y zenon_Tx_c))))) (fun(zenon_Ty_j:abst_T) zenon_Hc=>
(zenon_notimply _ _ (fun zenon_Hb zenon_Ha=>(let zenon_H5:=zenon_Hb in (
let zenon_H4:=zenon_Ha in (zenon_all _p_T_T (fun x:_p_T_T=>(forall y
:_p_T_T,((Is_true (_p_T_equal x y))->(Is_true (_p_T_equal y x)))))
zenon_Tx_c (fun zenon_H8=>(zenon_all _p_T_T (fun y:_p_T_T=>((Is_true (
_p_T_equal zenon_Tx_c y))->(Is_true (_p_T_equal y zenon_Tx_c))))
zenon_Ty_j (fun zenon_H7=>(zenon_imply _ _ (fun zenon_H6=>(zenon_H6
zenon_H5)) (fun zenon_H3=>(zenon_H4 zenon_H3)) zenon_H7)) zenon_H8))
_p_T_equal_symmetric)))) zenon_Hc)) zenon_Hd)) zenon_He)) zenon_Hf))
zenon_G)))).
Qed.

0
c5d9363ecbdc3b11d080ddc44e1af856
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
754

%%begin-auto-proof
%%name: for_zenon_equal_transitive
    
    
    
    (* Methods to use for automated proof. *)
    (* For species parameter method used via "by property value#T!equal_transitive". *)
    Parameter _p_T_equal_transitive :
      forall x  y  z : _p_T_T,
        Is_true ((_p_T_equal x y)) ->
          Is_true ((_p_T_equal y z)) -> Is_true ((_p_T_equal x z)).
    (* For method of Self used via "by definition of !equal". *)
    Definition abst_equal (x : abst_T) (y : abst_T) : basics.bool__t :=
      (_p_T_equal x y).
    (* Theorem's body. *)
    Theorem for_zenon_equal_transitive :
    forall x  y  z : abst_T,
      Is_true ((abst_equal x y)) ->
        Is_true ((abst_equal y z)) -> Is_true ((abst_equal x z)).
%%end-auto-proof
0
c64835edbac2d1e8c2c5ad83087f9a70
proof
3275
Theorem for_zenon_equal_transitive:(forall x:abst_T,(forall y:abst_T,(
forall z:abst_T,((Is_true (abst_equal x y))->((Is_true (abst_equal y z))
->(Is_true (abst_equal x z))))))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_notallex (fun x:abst_T=>(forall y:abst_T,(
forall z:abst_T,((Is_true (abst_equal x y))->((Is_true (abst_equal y z))
->(Is_true (abst_equal x z))))))) (fun zenon_H24=>(zenon_ex abst_T (fun
x:abst_T=>(~(forall y:abst_T,(forall z:abst_T,((Is_true (abst_equal x y)
)->((Is_true (abst_equal y z))->(Is_true (abst_equal x z)))))))) (fun(
zenon_Tx_c:abst_T) zenon_H23=>(zenon_notallex (fun y:abst_T=>(forall z
:abst_T,((Is_true (abst_equal zenon_Tx_c y))->((Is_true (abst_equal y z)
)->(Is_true (abst_equal zenon_Tx_c z)))))) (fun zenon_H22=>(zenon_ex
abst_T (fun y:abst_T=>(~(forall z:abst_T,((Is_true (abst_equal
zenon_Tx_c y))->((Is_true (abst_equal y z))->(Is_true (abst_equal
zenon_Tx_c z))))))) (fun(zenon_Ty_d:abst_T) zenon_H21=>(zenon_notallex (
fun z:abst_T=>((Is_true (abst_equal zenon_Tx_c zenon_Ty_d))->((Is_true (
abst_equal zenon_Ty_d z))->(Is_true (abst_equal zenon_Tx_c z))))) (fun
zenon_H20=>(zenon_ex abst_T (fun z:abst_T=>(~((Is_true (abst_equal
zenon_Tx_c zenon_Ty_d))->((Is_true (abst_equal zenon_Ty_d z))->(Is_true
(abst_equal zenon_Tx_c z)))))) (fun(zenon_Tz_f:abst_T) zenon_H1f=>(
zenon_notimply _ _ (fun zenon_H1d zenon_H1e=>(zenon_notimply _ _ (fun
zenon_H1c zenon_H1b=>(let zenon_Hc:=zenon_H1d in (let zenon_H7
:=zenon_H1c in (let zenon_H6:=zenon_H1b in (let zenon_H18:=(fun
zenon_H1a=>(zenon_and _ _ (fun zenon_H16 zenon_Hd=>(zenon_Hd zenon_Hc))
zenon_H1a)) in (let zenon_H4:=(fun zenon_H19=>(zenon_subst _ (fun
zenon_Vf=>(Is_true zenon_Vf)) (_p_T_equal zenon_Ty_d zenon_Tz_f) (
_p_T_equal zenon_Tx_c zenon_Tz_f) (fun zenon_H8=>(zenon_subst _ (fun
zenon_Vg=>(~((_p_T_equal zenon_Vg zenon_Tz_f) = (_p_T_equal zenon_Tx_c
zenon_Tz_f)))) zenon_Ty_d zenon_Tx_c (fun zenon_H13=>(zenon_notand _ _ (
fun zenon_H17=>(zenon_H17 (fun zenon_H15=>(let zenon_H12:=(fun
zenon_H14=>(zenon_subst _ (fun zenon_Vh=>(zenon_Vh = zenon_Tx_c))
zenon_Tx_c zenon_Ty_d (fun zenon_H16=>(zenon_H16 zenon_H15)) zenon_H13
zenon_H14)) in (zenon_noteq _ zenon_Tx_c zenon_H12))))) (fun zenon_H11=>
(zenon_H11 (fun zenon_Hc=>(zenon_all _p_T_T (fun x:_p_T_T=>(forall y
:_p_T_T,(forall z:_p_T_T,((Is_true (_p_T_equal x y))->((Is_true (
_p_T_equal y z))->(Is_true (_p_T_equal x z))))))) zenon_Tx_c (fun
zenon_H10=>(zenon_all _p_T_T (fun y:_p_T_T=>(forall z:_p_T_T,((Is_true (
_p_T_equal zenon_Tx_c y))->((Is_true (_p_T_equal y z))->(Is_true (
_p_T_equal zenon_Tx_c z)))))) zenon_Ty_d (fun zenon_Hf=>(zenon_all
_p_T_T (fun z:_p_T_T=>((Is_true (_p_T_equal zenon_Tx_c zenon_Ty_d))->((
Is_true (_p_T_equal zenon_Ty_d z))->(Is_true (_p_T_equal zenon_Tx_c z)))
)) zenon_Tz_f (fun zenon_He=>(zenon_imply _ _ (fun zenon_Hd=>(zenon_Hd
zenon_Hc)) (fun zenon_Hb=>(zenon_imply _ _ (fun zenon_Ha=>(zenon_Ha
zenon_H7)) (fun zenon_H9=>(zenon_H6 zenon_H9)) zenon_Hb)) zenon_He))
zenon_Hf)) zenon_H10)) _p_T_equal_transitive)))) zenon_H18)) (
zenon_notnot _ (refl_equal (_p_T_equal zenon_Tx_c zenon_Tz_f)))
zenon_H8)) zenon_H6 zenon_H7)) in (zenon_noteq _ zenon_Tz_f zenon_H4))))
))) zenon_H1e)) zenon_H1f)) zenon_H20)) zenon_H21)) zenon_H22))
zenon_H23)) zenon_H24)) zenon_G)))).
Qed.

0
1b24e709969f063d153c00b56f505c81
err
0
d41d8cd98f00b204e9800998ecf8427e
end
begin
798

%%begin-auto-proof
%%name: for_zenon_tol_is_positive
    
    
    
    (* Methods to use for automated proof. *)
    (* For step <1>1. *)
    Parameter __J_1_LEMMA :
      (Is_true ((basic_type.Coll_int_value.pos
                  (basic_type.Coll_int_value.of_int 2)))).
    (* For toplevel collection's method used via "by property basic_type#Coll_int_value!pos". *)
    Parameter basic_type.Coll_int_value.pos : abst_T -> basics.bool__t.
    (* For toplevel collection's method used via "by property basic_type#Coll_int_value!of_int". *)
    Parameter basic_type.Coll_int_value.of_int : basics.int__t -> abst_T.
    (* Theorem's body. *)
    Theorem for_zenon_tol_is_positive :
    Is_true ((basic_type.Coll_int_value.pos
               (basic_type.Coll_int_value.of_int 2))).
%%end-auto-proof
0
cd4eccced3c221ff93c0ad587d47bff7
proof
182
Theorem for_zenon_tol_is_positive:(Is_true (
basic_type.Coll_int_value.pos (basic_type.Coll_int_value.of_int 2))).
Proof.
exact(
(NNPP _ (fun zenon_G=>(zenon_G __J_1_LEMMA)))).
Qed.

0
2217327495a0d073c6b7bf82608c3cbf
err
0
d41d8cd98f00b204e9800998ecf8427e
end
